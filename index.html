<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AZ-204</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#create-azure-app-service-web-apps">Create Azure App Service web apps</a>
<ul>
<li><a href="#explore-azure-app-service">Explore Azure App Service</a></li>
<li><a href="#scale-apps-in-azure-app-service">Scale apps in Azure App Service</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="create-azure-app-service-web-apps">Create Azure App Service web apps</h1>
<h2 id="explore-azure-app-service">Explore Azure App Service</h2>
<h3 id="examine-azure-app-service">Examine Azure App Service</h3>
<p>Azure App Service is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends.<br>
Supported programming languages:</p>
<ul>
<li>.NET,</li>
<li>.NET Core,</li>
<li>Java,</li>
<li>Ruby,</li>
<li>Node.js,</li>
<li>PHP,</li>
<li>Python.<br>
Applications run and scale with ease on both Windows and Linux-based environments.</li>
</ul>
<h4 id="features">Features:</h4>
<ul>
<li>Built-in auto scale support: Baked into Azure App Service is the ability to scale up/down or scale out/in.</li>
<li>Continuous integration/deployment support: The Azure portal provides out-of-the-box continuous integration and deployment with Azure DevOps, GitHub, Bitbucket, FTP, or a local Git repository on your development machine.</li>
<li>Deployment slots: When you deploy your web app, web app on Linux, mobile back end, or API app to Azure App Service, you can use a separate deployment slot instead of the default production slot when you’re running in the Standard, Premium, or Isolated App Service plan tier.</li>
<li>App Service on Linux: App Service can also host web apps natively on Linux for supported application stacks.</li>
</ul>
<p>App Service on Linux does have some limitations:</p>
<ul>
<li>App Service on Linux is not supported on Shared pricing tier.</li>
<li>You can’t mix Windows and Linux apps in the same App Service plan.</li>
</ul>
<h3 id="examine-azure-app-service-plans">Examine Azure App Service plans</h3>
<p>In App Service, an app (Web Apps, API Apps, or Mobile Apps) always runs in an <em>App Service plan</em>. An App Service plan defines a set of compute resources for a web app to run. One or more apps can be configured to run on the same computing resources (or in the same App Service plan).</p>
<p>Each App Service plan defines:</p>
<ul>
<li>Region (West US, East US, etc.)</li>
<li>Number of VM instances</li>
<li>Size of VM instances (Small, Medium, Large)</li>
<li>Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated)</li>
</ul>
<p>The <em>pricing tier</em> of an App Service plan determines what App Service features you get and how much you pay for the plan. There are a few categories of pricing tiers:</p>
<ul>
<li><strong>Shared compute</strong>: Both <strong>Free</strong> and <strong>Shared</strong> share the resource pools of your apps with the apps of other customers. These tiers allocate CPU quotas to each app that runs on the shared resources, and the resources can’t scale out.</li>
<li><strong>Dedicated compute</strong>: The <strong>Basic</strong>, <strong>Standard</strong>, <strong>Premium</strong>, <strong>PremiumV2</strong>, and <strong>PremiumV3</strong> tiers run apps on dedicated Azure VMs. Only apps in the same App Service plan share the same compute resources. The higher the tier, the more VM instances are available to you for scale-out.</li>
<li><strong>Isolated</strong>: This tier runs dedicated Azure VMs on dedicated Azure Virtual Networks. It provides network isolation on top of compute isolation to your apps. It provides the maximum scale-out capabilities.</li>
<li><strong>Consumption:</strong> This tier is only available to <em>function apps</em>. It scales the functions dynamically depending on workload.</li>
</ul>
<h4 id="how-does-my-app-run-and-scale">How does my app run and scale?</h4>
<p>The App Service plan is the <strong>scale unit</strong> of the App Service apps:</p>
<ul>
<li>An app runs on all the VM instances configured in the App Service plan.</li>
<li>If multiple apps are in the same App Service plan, they all share the same VM instances.</li>
<li>If you have multiple deployment slots for an app, all deployment slots also run on the same VM instances.</li>
<li>If you enable diagnostic logs, perform backups, or run WebJobs, they also use CPU cycles and memory on these VM instances.</li>
</ul>
<h4 id="what-if-my-app-needs-more-capabilities-or-features">What if my app needs more capabilities or features?</h4>
<p>Isolate your app into a new App Service plan when:</p>
<ul>
<li>The app is resource-intensive.</li>
<li>You want to scale the app independently from the other apps in the existing plan.</li>
<li>The app needs resource in a different geographical region.</li>
</ul>
<h3 id="deploy-to-app-service">Deploy to App Service</h3>
<h4 id="automated-deployment">Automated deployment</h4>
<p>Azure supports automated deployment directly from several sources. The following options are available:</p>
<ul>
<li>Azure DevOps</li>
<li>GitHub</li>
<li>Bitbucket</li>
</ul>
<h4 id="manual-deployment">Manual deployment</h4>
<p>There are a few options that you can use to manually push your code to Azure:</p>
<ul>
<li><strong>Git</strong>: App Service web apps feature a Git URL that you can add as a remote repository.</li>
<li><strong>CLI</strong>: <code>webapp up</code> is a feature of the <code>az</code> command-line interface that packages your app and deploys it.</li>
<li><strong>Zip deploy</strong>: Use <code>curl</code> or a similar HTTP utility to send a ZIP of your application files to App Service.</li>
<li><strong>FTP/S</strong>: FTP or FTPS is a traditional way of pushing your code to many hosting environments, including App Service.</li>
</ul>
<h4 id="use-deployment-slots">Use deployment slots</h4>
<p>Whenever possible, use deployment slots when deploying a new production build. When using a Standard App Service Plan tier or better, you can deploy your app to a staging environment and then swap your staging and production slots. The swap operation warms up the necessary worker instances to match your production scale, thus eliminating downtime.</p>
<h3 id="explore-authentication-and-authorization-in-app-service">Explore authentication and authorization in App Service</h3>
<p>Azure App Service provides built-in authentication and authorization support by writing minimal or no code.</p>
<h4 id="why-use-the-built-in-authentication">Why use the built-in authentication?</h4>
<p>The built-in authentication feature for App Service and Azure Functions can save you time and effort by providing out-of-the-box authentication with federated identity providers.</p>
<h4 id="identity-providers">Identity providers</h4>
<p>App Service uses federated identity, in which a third-party identity provider manages the user identities and authentication flow for you. The following identity providers are available by default:</p>
<ul>
<li>Microsoft Identity Platform</li>
<li>Facebook</li>
<li>Google</li>
<li>Twitter</li>
<li>Any OpenID Connect provider</li>
</ul>
<h5 id="how-it-works">How it works</h5>
<p>The authentication and authorization module runs in the same sandbox as your application code. When it’s enabled, every incoming HTTP request passes through it before being handled by your application code. This module handles several things for your app:</p>
<ul>
<li>Authenticates users with the specified provider</li>
<li>Validates, stores, and refreshes tokens</li>
<li>Manages the authenticated session</li>
<li>Injects identity information into request headers</li>
</ul>
<p>The module runs separately from your application code and is configured using app settings.</p>
<h5 id="authentication-flow">Authentication flow</h5>
<ul>
<li>Without provider SDK: The application delegates federated sign-in to App Service. This is typically the case with browser apps, which can present the provider’s login page to the user. The server code manages the sign-in process, so it is also called <em>server-directed flow</em> or <em>server flow</em>.</li>
<li>With provider SDK: The application signs users in to the provider manually and then submits the authentication token to App Service for validation. This is typically the case with browser-less apps, which can’t present the provider’s sign-in page to the user. The application code manages the sign-in process, so it is also called <em>client-directed flow</em> or <em>client flow</em>. This applies to REST APIs, Azure Functions, JavaScript browser clients, and native mobile apps that sign users in using the provider’s SDK.</li>
</ul>

<table>
<thead>
<tr>
<th>Step</th>
<th>Without provider SDK</th>
<th>With provider SDK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sign user in</td>
<td>Redirects client to <code>/.auth/login/&lt;provider&gt;</code>.</td>
<td>Client code signs user in directly with provider’s SDK and receives an authentication token. For information, see the provider’s documentation.</td>
</tr>
<tr>
<td>Post-authentication</td>
<td>Provider redirects client to <code>/.auth/login/&lt;provider&gt;/callback</code>.</td>
<td>Client code posts token from provider to <code>/.auth/login/&lt;provider&gt;</code> for validation.</td>
</tr>
<tr>
<td>Establish authenticated session</td>
<td>App Service adds authenticated cookie to response.</td>
<td>App Service returns its own authentication token to client code.</td>
</tr>
<tr>
<td>Serve authenticated content</td>
<td>Client includes authentication cookie in subsequent requests (automatically handled by browser).</td>
<td>Client code presents authentication token in <code>X-ZUMO-AUTH</code> header (automatically handled by Mobile Apps client SDKs).</td>
</tr>
</tbody>
</table><h5 id="authorization-behavior">Authorization behavior</h5>
<ul>
<li>Allow unauthenticated requests: This option defers authorization of unauthenticated traffic to your application code.</li>
<li>Require authentication: This option will reject any unauthenticated traffic to your application. This rejection can be a redirect action to one of the configured identity providers.</li>
</ul>
<h3 id="discover-app-service-networking-features">Discover App Service networking features</h3>
<p>By default, apps hosted in App Service are accessible directly through the internet and can reach only internet-hosted endpoints. But for many applications, you need to control the inbound and outbound network traffic.</p>
<p>Deployment-Types:</p>
<ul>
<li>Multi-Tenant pricing SKUs: Free, Shared, Basic, Standard, Premium, PremiumV2, and PremiumV3</li>
<li>Single-Tenant pricing SKU:  Isolated</li>
</ul>
<h4 id="multi-tenant-app-service-networking-features">Multi-tenant App Service networking features</h4>
<p>All the roles in an App Service deployment exist in a multi-tenant network. The roles that handle incoming HTTP or HTTPS requests are called <em>front ends</em>. The roles that host the customer workload are called <em>workers</em>.</p>
<p>Because there are many different customers in the same App Service scale unit, you can’t connect the App Service network directly to your network. Instead of connecting the networks, you need features to handle the various aspects of application communication.</p>

<table>
<thead>
<tr>
<th>Inbound features</th>
<th>Outbound features</th>
</tr>
</thead>
<tbody>
<tr>
<td>App-assigned address</td>
<td>Hybrid Connections</td>
</tr>
<tr>
<td>Access restrictions</td>
<td>Gateway-required virtual network integration</td>
</tr>
<tr>
<td>Service endpoints</td>
<td>Virtual network integration</td>
</tr>
<tr>
<td>Private endpoints</td>
<td></td>
</tr>
</tbody>
</table><p>The following inbound use cases are examples of how to use App Service networking features to control traffic inbound to your app.</p>

<table>
<thead>
<tr>
<th>Inbound use case</th>
<th>Feature</th>
</tr>
</thead>
<tbody>
<tr>
<td>Support IP-based SSL needs for your app</td>
<td>App-assigned address</td>
</tr>
<tr>
<td>Support unshared dedicated inbound address for your app</td>
<td>App-assigned address</td>
</tr>
<tr>
<td>Restrict access to your app from a set of well-defined addresses</td>
<td>Access restrictions</td>
</tr>
</tbody>
</table><h4 id="default-networking-behavior">Default networking behavior</h4>
<p>The Free and Shared SKU plans host customer workloads on multitenant workers. The Basic and higher plans host customer workloads that are dedicated to only one App Service plan.</p>
<h5 id="outbound-addresses">Outbound addresses</h5>
<p>The worker VMs are broken down in large part by the App Service plans.</p>
<ul>
<li>The Free, Shared, Basic, Standard, and Premium plans all use the same worker VM type.</li>
<li>The PremiumV2 plan uses another VM type.</li>
<li>PremiumV3 uses yet another VM type.<br>
When you change the VM family, you get a different set of outbound addresses.</li>
</ul>
<p>The outbound addresses used by your app for making outbound calls are listed in the properties for your app. These addresses are shared by all the apps running on the same worker VM family in the App Service deployment.</p>
<h5 id="find-outbound-ips">Find outbound IPs</h5>
<p>To find the outbound IP addresses currently used by your app in the Azure portal, click <strong>Properties</strong> in your app’s left-hand navigation. If you want to see all the addresses that your app might use in a scale unit, there’s a property called <code>possibleOutboundAddresses</code> that will list them.</p>
<h3 id="configure-web-app-settings">Configure web app settings</h3>
<h4 id="configure-application-settings">Configure application settings</h4>
<p>In App Service, app settings are variables passed as environment variables to the application code.</p>
<p><img src="https://docs.microsoft.com/en-us/learn/wwl-azure/configure-web-app-settings/media/configure-app-settings.png" alt="Navigating to Configuration > Application settings"><br>
For <a href="http://ASP.NET">ASP.NET</a> and <a href="http://ASP.NET">ASP.NET</a> Core developers, setting app settings in App Service are like setting them in <code>&lt;appSettings&gt;</code> in <em>Web.config</em> or <em>appsettings.json</em>, but the values in App Service override the ones in <em>Web.config</em> or <em>appsettings.json</em>.</p>
<p>App settings are always encrypted when stored (encrypted-at-rest).</p>
<h4 id="adding-and-editing-settings">Adding and editing settings</h4>
<p><img src="https://docs.microsoft.com/en-us/learn/wwl-azure/configure-web-app-settings/media/app-configure-slotsetting.png" alt="Selecting deployment slot setting to stick the setting to the current slot.">If you are using deployment slots you can specify if your setting is swappable or not. In the dialog, you can stick the setting to the current slot.</p>
<h5 id="editing-application-settings-in-bulk">Editing application settings in bulk</h5>
<p>To add or edit app settings in bulk, click the <strong>Advanced</strong> edit button.</p>
<pre><code>[
  {
    "name": "&lt;key-1&gt;",
    "value": "&lt;value-1&gt;",
    "slotSetting": false
  },
  {
    "name": "&lt;key-2&gt;",
    "value": "&lt;value-2&gt;",
    "slotSetting": false
  },
  ...
]
</code></pre>
<h3 id="configure-general-settings">Configure general settings</h3>
<ul>
<li><strong>Stack settings</strong>: The software stack to run the app, including the language and SDK versions.<br>
<img src="https://docs.microsoft.com/en-us/learn/wwl-azure/configure-web-app-settings/media/open-general-linux.png" alt="Establishing the stack settings which includes the programming language.">- <strong>Platform settings</strong>: Lets you configure settings for the hosting platform</li>
<li><strong>Debugging</strong>: Enable remote debugging for <a href="http://ASP.NET">ASP.NET</a>, <a href="http://ASP.NET">ASP.NET</a> Core, or Node.js apps.</li>
<li><strong>Incoming client certificates</strong>: require client certificates in mutual authentication.</li>
</ul>
<h3 id="configure-path-mappings">Configure path mappings</h3>
<p>In the <strong>Configuration &gt; Path mappings</strong> section you can configure handler mappings, and virtual application and directory mappings. The <strong>Path mappings</strong> page will display different options based on the OS type.</p>
<h4 id="windows-apps-uncontainerized">Windows apps (uncontainerized)</h4>
<p>For Windows apps, you can customize the IIS handler mappings and virtual applications and directories. Handler mappings let you add custom script processors to handle requests for specific file extensions.</p>
<ul>
<li><strong>Extension</strong>: The file extension you want to handle, such as *<em>.php</em> or <em>handler.fcgi</em>.</li>
<li><strong>Script processor</strong>: The absolute path of the script processor.</li>
<li><strong>Arguments</strong>: Optional command-line arguments for the script processor.</li>
</ul>
<h4 id="linux-and-containerized-apps">Linux and containerized apps</h4>
<p>You can add custom storage for your containerized app.</p>
<h3 id="enable-diagnostic-logging">Enable diagnostic logging</h3>
<p>| Type | Platform | Location | Description |<br>
| Application logging | Windows, Linux | App Service file system and/or Azure Storage blobs | Logs messages generated by your application code. Each message is assigned one of the following categories: <strong>Critical</strong>, <strong>Error</strong>, <strong>Warning</strong>, <strong>Info</strong>, <strong>Debug</strong>, and <strong>Trace</strong>. |<br>
| Web server logging | Windows | App Service file system or Azure Storage blobs | Raw HTTP request data in the W3C extended log file format.  |<br>
| Detailed error logging | Windows | App Service file system | Copies of the <em>.html</em> error pages that would have been sent to the client browser. |<br>
| Failed request tracing | Windows | App Service file system | Detailed tracing information on failed requests  |<br>
| Deployment logging | Windows, Linux | App Service file system | Helps determine why a deployment failed. Deployment logging happens automatically and there are no configurable settings for deployment logging. |</p>
<h4 id="enable-application-logging-windows">Enable application logging (Windows)</h4>
<p>To enable application logging for Windows apps in the Azure portal, navigate to your app and select <strong>App Service logs</strong>. Available Options:</p>
<ul>
<li>Application Logging (Filesystem)</li>
<li>Application Logging (Blob),</li>
</ul>
<h4 id="enable-application-logging-linuxcontainer">Enable application logging (Linux/Container)</h4>
<p>Available Options:</p>
<ul>
<li>File System</li>
</ul>
<h4 id="enable-web-server-logging">Enable web server logging</h4>
<p>Available Options:</p>
<ul>
<li>Filesystem)</li>
<li>Blob</li>
</ul>
<h4 id="add-log-messages-in-code">Add log messages in code</h4>
<p>In your application code, you use the usual logging facilities to send log messages to the application logs.</p>
<h4 id="stream-logs">Stream logs</h4>
<p>Before you stream logs in real time, enable the log type that you want. Any information written to files ending in .txt, .log, or .htm that are stored in the <code>/LogFiles</code> directory (<code>d:/home/logfiles</code>) is streamed by App Service. Places, where logs can be streamed:</p>
<ul>
<li>Azure portal</li>
<li>Azure CLI</li>
<li>Local console</li>
</ul>
<h4 id="access-log-files">Access log files</h4>
<p>If you configure the Azure Storage blobs option for a log type, you need a client tool that works with Azure Storage.</p>
<p>For logs stored in the App Service file system, the easiest way is to download the ZIP file in the browser</p>
<h3 id="configure-security-certificates">Configure security certificates</h3>
<p>A certificate uploaded into an app is stored in a deployment unit that is bound to the app service plan’s resource group and region combination (internally called a <em>webspace</em>). This makes the certificate accessible to other apps in the same resource group and region combination.</p>
<ul>
<li>Create a free App Service managed certificate</li>
<li>Purchase an App Service certificate</li>
<li>Import a certificate from Key Vault</li>
<li>Upload a private certificate</li>
<li>Upload a public certificate: Public certificates are not used to secure custom domains, but you can load them into your code if you need them to access remote resources.</li>
</ul>
<h4 id="private-certificate-requirements">Private certificate requirements</h4>
<p>The free <strong>App Service managed certificate</strong> and the <strong>App Service certificate</strong> already satisfy the requirements of App Service. If you want to use a private certificate in App Service, your certificate must meet the following requirements:</p>
<ul>
<li>Exported as a password-protected PFX file, encrypted using triple DES.</li>
<li>Contains private key at least 2048 bits long</li>
<li>Contains all intermediate certificates in the certificate chain</li>
</ul>
<p>To secure a custom domain in a TLS binding, the certificate has additional requirements:</p>
<ul>
<li>Contains an Extended Key Usage for server authentication (OID = 1.3.6.1.5.5.7.3.1)</li>
<li>Signed by a trusted certificate authority</li>
</ul>
<h4 id="creating-a-free-managed-certificate">Creating a free managed certificate</h4>
<p>To create custom TLS/SSL bindings or enable client certificates for your App Service app, your App Service plan must be in the <strong>Basic</strong>, <strong>Standard</strong>, <strong>Premium</strong>, or <strong>Isolated</strong> tier.</p>
<p>It’s a TLS/SSL server certificate that’s fully managed by App Service and renewed continuously. You create the certificate and bind it to a custom domain, and let App Service do the rest.</p>
<h4 id="import-an-app-service-certificate">Import an App Service Certificate</h4>
<p>If you purchase an App Service Certificate from Azure, Azure manages the following tasks:</p>
<ul>
<li>Takes care of the purchase process from GoDaddy.</li>
<li>Performs domain verification of the certificate.</li>
<li>Maintains the certificate in Azure Key Vault.</li>
<li>Manages certificate renewal.</li>
<li>Synchronize the certificate automatically with the imported copies in App Service apps.</li>
</ul>
<h4 id="upload-a-private-certificate">Upload a private certificate</h4>
<p>If your certificate authority gives you multiple certificates in the certificate chain, you need to merge the certificates in order. Then you can Export your merged TLS/SSL certificate with the private key that your certificate request was generated with.</p>
<h4 id="enforce-https">Enforce HTTPS</h4>
<p>By default, anyone can still access your app using HTTP. You can redirect all HTTP requests to the HTTPS port.<br>
<img src="https://docs.microsoft.com/en-us/learn/wwl-azure/configure-web-app-settings/media/enforce-https.png" alt="Enabling HTTPS Only in your web app."></p>
<h3 id="manage-app-features">Manage app features</h3>
<p>Feature management is a modern software-development practice that decouples feature release from code deployment and enables quick changes to feature availability on demand. It uses a technique called feature flags (also known as feature toggles, feature switches, and so on) to dynamically administer a feature’s lifecycle.</p>
<h4 id="basic-concepts">Basic concepts</h4>
<ul>
<li><strong>Feature flag</strong>: The state of the feature flag triggers whether the code block runs or not.</li>
<li><strong>Feature manager</strong>: A feature manager is an application package that handles the lifecycle of all the feature flags in an application.</li>
<li><strong>Filter</strong>: A filter is a rule for evaluating the state of a feature flag.</li>
</ul>
<p>An effective implementation of feature management consists of at least two components working in concert:</p>
<ul>
<li>An application that makes use of feature flags.</li>
<li>A separate repository that stores the feature flags and their current states.</li>
</ul>
<h4 id="feature-flag-usage-in-code">Feature flag usage in code</h4>
<pre><code>if (featureFlag) {
    // Run the following code
}
</code></pre>
<h4 id="feature-flag-declaration">Feature flag declaration</h4>
<p>Each feature flag has two parts: a name and a list of one or more filters that are used to evaluate if a feature’s state is <em>on</em> (that is, when its value is <code>True</code>). A filter defines a use case for when a feature should be turned on.</p>
<p>The feature manager supports <em>appsettings.json</em> as a configuration source for feature flags.</p>
<h4 id="feature-flag-repository">Feature flag repository</h4>
<p>To use feature flags effectively, you need to externalize all the feature flags used in an application. This approach allows you to change feature flag states without modifying and redeploying the application itself. Azure App Configuration is designed to be a centralized repository for feature flags.</p>
<h2 id="scale-apps-in-azure-app-service">Scale apps in Azure App Service</h2>
<h3 id="examine-autoscale-factors">Examine autoscale factors</h3>
<h4 id="what-is-autoscaling">What is autoscaling?</h4>
<p>Autoscaling is a cloud system or process that adjusts available resources based on the current demand. Autoscaling performs scaling <em>in and out</em>, as opposed to scaling <em>up and down</em>. Autoscaling can be triggered according to a schedule, or by assessing whether the system is running short on resources.</p>
<h4 id="azure-app-service-autoscaling">Azure App Service Autoscaling</h4>
<p>Autoscaling in Azure App Service monitors the resource metrics of a web app as it runs. It detects situations where additional resources are required to handle an increasing workload, and ensures those resources are available before the system becomes overloaded.</p>
<h5 id="autoscaling-rules">Autoscaling rules</h5>
<p>Autoscaling makes its decisions based on rules that you define. A rule specifies the threshold for a metric, and triggers an autoscale event when this threshold is crossed. Autoscaling can also deallocate resources when the workload has diminished.</p>
<h4 id="when-should-you-consider-autoscaling">When should you consider autoscaling?</h4>
<p>Autoscaling provides elasticity for your services. It’s a suitable solution when hosting any application when you can’t easily predict the workload in advance, or when the workload is likely to vary by date or time.</p>
<p>Autoscaling improves availability and fault tolerance.</p>
<p>Autoscaling works by adding or removing web servers. If your web apps perform resource-intensive processing as part of each request, then autoscaling might not be an effective approach. In these situations, manually scaling up may be necessary.</p>
<p>Autoscaling isn’t the best approach to handling long-term growth. Autoscaling has an overhead associated with monitoring resources and determining whether to trigger a scaling event. In this scenario, if you can anticipate the rate of growth, manually scaling the system over time may be a more cost effective approach.</p>
<p>The number of instances of a service is also a factor. The fewer the number of instances initially, the less capacity you have to handle an increasing workload while autoscaling spins up additional instances.</p>
<h3 id="identify-autoscale-factors">Identify autoscale factors</h3>
<p>Autoscaling enables you to specify the conditions under which a web app should be scaled out, and back in again:</p>
<ul>
<li>Scale based on a metric, such as the length of the disk queue, or the number of HTTP requests awaiting processing.</li>
<li>Scale to a specific instance count according to a schedule. For example, you can arrange to scale out at a particular time of day, or on a specific date or day of the week. You also specify an end date, and the system will scale back in at this time.</li>
</ul>
<p>When the web app scales out, Azure starts new instances of the hardware defined by the App Service Plan to the app.<br>
To prevent runaway autoscaling, an App Service Plan has an instance limit.</p>
<h4 id="metrics-for-autoscale-rules">Metrics for autoscale rules</h4>
<ul>
<li><strong>CPU Percentage</strong></li>
<li><strong>Memory Percentage</strong></li>
<li><strong>Disk Queue Length</strong></li>
<li><strong>Http Queue Length</strong></li>
<li><strong>Data In</strong>. This metric is the number of bytes received across all instances.</li>
<li><strong>Data Out</strong>. This metric is the number of bytes sent by all instances.</li>
</ul>
<h4 id="how-an-autoscale-rule-analyzes-metrics">How an autoscale rule analyzes metrics</h4>
<p>Autoscaling works by analyzing trends in metric values over time across all instances.</p>
<p>In the first step, an autoscale rule aggregates the values retrieved for a metric for all instances across a period of time known as the <em>time grain</em>.Each metric has its own intrinsic time grain, but in most cases this period is 1 minute. The aggregated value is known as the <em>time aggregation</em>. The options available are <em>Average</em>, <em>Minimum</em>, <em>Maximum</em>, <em>Total</em>, <em>Last</em>, and <em>Count</em>.</p>
<p>autoscale rule performs a second step that performs a further aggregation of the value calculated by the <em>time aggregation</em> over a longer, user-specified period, known as the <em>Duration</em>. The minimum <em>Duration</em> is 5 minutes.</p>
<p>The aggregation calculation for the <em>Duration</em> can be different from that of the <em>time grain</em>.</p>
<h4 id="autoscale-actions">Autoscale actions</h4>
<p>When an autoscale rule detects that a metric has crossed a threshold, it can perform an autoscale action. An autoscale action can be <em>scale-out</em> or <em>scale-in</em>.</p>
<p>An autoscale action has a <em>cool down</em> period, specified in minutes. During this interval, the scale rule won’t be triggered again. Remember that it takes time to start up or shut down instances, and so any metrics gathered might not show any significant changes for several minutes. The minimum cool down period is five minutes.</p>
<h4 id="pairing-autoscale-rules">Pairing autoscale rules</h4>
<p>You should plan for scaling-in when a workload decreases. Consider defining autoscale rules in pairs in the same autoscale condition.</p>
<h4 id="combining-autoscale-rules">Combining autoscale rules</h4>
<p>A single autoscale condition can contain several autoscale rules (for example, a scale-out rule and the corresponding scale-in rule). However, the autoscale rules in an autoscale condition don’t have to be directly related. When determining whether to scale out, the autoscale action will be performed if <strong>any</strong> of the scale-out rules are met. When scaling in, the autoscale action will run <strong>only if all</strong> of the scale-in rules are met.</p>
<h3 id="enable-autoscale-in-app-service">Enable autoscale in App Service</h3>
<h4 id="enable-autoscaling">Enable autoscaling</h4>
<p>To get started with autoscaling navigate to your App Service plan in the Azure portal and select <strong>Scale out (App Service plan)</strong> in the <strong>Settings</strong> group in the left navigation pane. Selecting <strong>Custom autoscale</strong> reveals condition groups you can use to manage your scale settings.</p>
<p><img src="https://docs.microsoft.com/en-us/learn/wwl-azure/scale-apps-app-service/media/enable-autoscale.png" alt="Enabling autoscale"></p>
<h4 id="add-scale-conditions">Add scale conditions</h4>
<p>Once you enable autoscaling, you can edit the automatically created default scale condition, and you can add your own custom scale conditions.<br>
<img src="https://docs.microsoft.com/en-us/learn/wwl-azure/scale-apps-app-service/media/autoscale-conditions.png" alt="The condition page for an App Service Plan showing the default scale condition."><br>
<a href="https://docs.microsoft.com/en-us/learn/modules/scale-apps-app-service/4-autoscale-app-service">https://docs.microsoft.com/en-us/learn/modules/scale-apps-app-service/4-autoscale-app-service</a></p>

    </div>
  </div>
</body>

</html>
